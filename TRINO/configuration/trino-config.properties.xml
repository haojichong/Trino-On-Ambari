<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="configuration.xsl"?>

<configuration>
    <property>
        <name>http-server.http.port</name>
        <value>8285</value>
        <description>HTTP服务器的端口.Trino使用HTTP进行所有内部和外部通信.</description>
    </property>
    <property>
        <name>discovery.uri</name>
        <value>http://coordinator_host:8285</value>
        <description>协调器地址. 如果开启了Trino协调者高可用模式,则此处填Nginx地址.
            配置案例:http://192.168.100.100:8285
        </description>
    </property>
    <property>
        <name>http-server.log.path</name>
        <value>/var/log/trino/httpserver.log</value>
    </property>
    <property>
        <name>node-scheduler.include-coordinator</name>
        <value>false</value>
        <description>协调者角色是否也执行查询任务,默认情况下协调者仅接受请求分配任务而不执行任务,该配置项仅对协调者生效.
            对于较大的集群,协调器上的处理工作可能会影响查询性能,因为机器的资源无法用于调度/管理/监视查询执行等关键任务
        </description>
    </property>
    <property>
        <name>node-scheduler.max-splits-per-node</name>
        <value>256</value>
        <description>假设所有分割都具有标准分割权值,则可以为每个工作节点运行的分割总数的目标值.
            如果查询是批量提交的(例如,定期运行一大组报告),或者对于产生许多快速完成的分割,但不支持分配分割权重值以将其表示给分割调度程序的连接器,建议使用更高的值.
            增加这个值可以改善查询延迟,因为它可以确保工作线程有足够的拆分,使它们得到充分利用.
        </description>
    </property>
    <property>
        <name>node-scheduler.min-pending-splits-per-task</name>
        <value>16</value>
        <description>给定任务还有剩余的分割要处理,保证在节点上调度具有标准分割权重的未完成分割的最小数量(即使节点已经达到分割总数的限制).
            为了防止饥饿和死锁,需要允许每个阶段的最小分裂次数.
            此值必须小于或等于max-adjusted-pending- splitting -per-task和node-scheduler.
            由于同样的原因,每个节点的最大分裂通常会增加,如果设置得太高,也会有类似的缺点.
        </description>
    </property>
    <property>
        <name>node-scheduler.max-adjusted-pending-splits-per-task</name>
        <value>2000</value>
        <description>给定任务还有剩余的分割要处理,保证在节点上调度具有标准分割权重的未完成分割的最大数量(即使节点已经达到分割总数的限制).
            拆分队列大小在拆分调度期间动态调整,不能超过node-scheduler.max-adjusted-pending- splitting -per-task.
            如果节点处理分裂的速度比接收分裂的速度快,则每个任务的分裂队列大小将向上调整. 通常由于与节点调度程序相同的原因而增加.
            通常由于与节点调度程序相同的原因而增加.每个节点的最大分裂数,如果设置得太高,则缺点较小.
        </description>
    </property>
    <property>
        <name>node-scheduler.max-unacknowledged-splits-per-task</name>
        <value>2000</value>
        <description>在协调器上排队,但尚未发送或确认已被工作程序接收的分割的最大数目.
            这种限制执行优先于其他现有的分割限制配置,如节点调度程序.
            每个节点的最大分裂或节点调度程序.每个任务的最大调整挂起分割,旨在防止可能导致查询失败的大型任务更新请求.
        </description>
    </property>
    <property>
        <name>node-scheduler.min-candidates</name>
        <value>10</value>
        <description>节点调度器在选择分割的目标节点时评估的最小候选节点数.
            将此值设置得太低可能会阻止在所有工作节点上正确平衡分割.
            设置过高可能会增加查询延迟并增加协调器上的CPU使用.
        </description>
        <value-attributes>
            <type>int</type>
            <minimum>1</minimum>
            <increment-step>1</increment-step>
        </value-attributes>
    </property>
    <property>
        <name>node-scheduler.policy</name>
        <value>uniform</value>
        <description>设置要在调度分割时使用的节点调度程序策略.
            uniform:尝试在数据所在的主机上调度分割,同时在所有主机上保持均匀分布.
            topology:尝试根据节点和分割之间的拓扑距离来调度分割.
            对于分布式存储与Trino worker运行在相同节点上的集群,建议使用uniform.
            默认值uniform,可选项[uniform, topology]
        </description>
    </property>
    <property>
        <name>query.max-cpu-time</name>
        <value>1h</value>
        <description>查询任务在整个集群中可以使用的最大CPU时间,超过此限制的查询会被终止.
            配置案例:1d(1天)/1h(1小时)/30m(30分钟)
        </description>
    </property>
    <property>
        <name>query.max-memory</name>
        <value>20GB</value>
        <description>查询任务在整个集群中可以使用的最大内存,超过此限制的查询会被终止.
            配置案例:1GB/1MB/512kb(注意大小写)
        </description>
    </property>
    <property>
        <name>retry-policy</name>
        <value>QUERY</value>
        <description>查询任务失败重试策略,默认是NONE.
            NONE:任务失败不重试.
            QUERY:重试整个查询(在工作节点上发生错误时自动重试查询).
            TASK:重试单个任务(在失败的情况下重试单个查询任务).
        </description>
    </property>
    <property>
        <name>exchange.deduplication-buffer-size</name>
        <value>32MB</value>
        <description>容错执行用于存储查询阶段输出的协调器内存缓冲区的数据大小.
            如果在查询执行期间填充此缓冲区,则查询失败,并显示"任务描述符存储容量已超出错误"消息,除非配置了交换管理器.
            配置案例:1GB/1MB/512kb(注意大小写)
        </description>
    </property>
    <property>
        <name>fault-tolerant-execution.exchange-encryption-enabled</name>
        <value>true</value>
        <description>启用假脱机数据加密,详细信息请参见加密.如果Trino处理敏感数据,不建议将此属性设置为false.
        </description>
    </property>
    <property>
        <name>query.client.timeout</name>
        <value>5m</value>
        <description>配置集群在放弃和取消其工作之前,在不与客户机应用程序(如CLI)联系的情况下运行多长时间.</description>
    </property>
    <property>
        <name>query.execution-policy</name>
        <value>phased</value>
        <description>配置算法以组织查询的所有阶段的处理.您可以使用以下执行策略:
            phased:按顺序安排阶段,以避免由于阶段间依赖而造成的阻塞.该策略可以最大限度地利用集群资源,并提供最低地查询墙时间.
            all-at-once:一次调度查询的所有阶段.因此,集群资源利用率最初很高,但阶段间的依赖关系通常会阻止完全处理,并导致更长的队列时间,从而增加总体查询墙时间.
        </description>
    </property>
    <property>
        <name>query.low-memory-killer.policy</name>
        <value>total-reservation-on-blocked-nodes</value>
        <description>内存可用性低的情况下处理终止正在运行的查询.支持以下值:
            none:在内存不足的情况下不要终止任何查询.
            total-reservation:终止当前使用最多总内存的查询
            total-reservation-on-blocked-nodes:终止当前使用最多内存的查询,特别是在当前内存不足的节点上.
        </description>
    </property>
    <property>
        <name>task.low-memory-killer.policy</name>
        <value>total-reservation-on-blocked-nodes</value>
        <description>内存可用性低的情况下处理终止正在运行的查询.支持以下值:
            none:在内存不足的情况下不杀死任何任务.
            total-reservation-on-blocked-nodes:杀死那些在查询中启用了任务重试且当前占用内存最多的任务,特别是在内存不足的节点上.
            least-waste:杀死那些在查询中启用了任务重试并且在节点上使用大量内存的任务,这些节点现在内存不足.此策略避免杀死已经执行了很长时间的任务,因此不会浪费大量的工作.
        </description>
    </property>
    <property>
        <name>query.low-memory-killer.delay</name>
        <value>5m</value>
        <description>从内存耗尽到终止查询之间恢复的时间,当task.low-memory-killer.policy和query.low-memory-killer.delay都不为none是生效
            配置案例:1d(1天)/1h(1小时)/30m(30分钟)
        </description>
    </property>
    <property>
        <name>query.max-execution-time</name>
        <value>1h</value>
        <description>在终止查询之前,查询在集群上主动执行的最大允许时间.
            执行时间不包括队列中的分析、查询计划或等待时间.
            配置案例:1d(1天)/1h(1小时)/30m(30分钟)
        </description>
    </property>
    <property>
        <name>query.max-run-time</name>
        <value>2h</value>
        <description>查询在集群上处理的最长时间,在查询终止之前.
            该时间包括用于分析和计划的时间,也包括用于队列等待的时间,因此本质上这是自创建以来允许查询存在的时间.
            配置案例:1d(1天)/1h(1小时)/30m(30分钟)
        </description>
    </property>
    <property>
        <name>query.max-length</name>
        <value>10000000</value>
        <description>SQL查询文本允许的最大字符数.较长的查询不被处理,并以QUERY_TEXT_TOO_LARGE错误结束.
        </description>
        <value-attributes>
            <type>int</type>
            <minimum>10000</minimum>
            <maximum>1000000000</maximum>
            <increment-step>1</increment-step>
        </value-attributes>
    </property>
    <property>
        <name>query.max-stage-count</name>
        <value>150</value>
        <description>每个查询允许生成的最大阶段数.如果一个查询生成的阶段多于这个数,它就会被QUERY_HAS_TOO_MANY_STAGES错误终止.
        </description>
        <value-attributes>
            <type>int</type>
            <minimum>1</minimum>
            <increment-step>1</increment-step>
        </value-attributes>
    </property>
    <property>
        <name>query.max-history</name>
        <value>300</value>
        <description>在查询历史中保留的查询的最大数量,以提供统计信息和其他信息.
        </description>
        <value-attributes>
            <type>int</type>
            <minimum>1</minimum>
            <increment-step>1</increment-step>
        </value-attributes>
    </property>
    <property>
        <name>query.min-expire-age</name>
        <value>15m</value>
        <description>查询在历史记录中过期前的最小年龄.过期的查询将从查询历史缓冲区中删除,并且在Web UI中不再可用.
            配置案例:1d(1天)/1h(1小时)/30m(30分钟)
        </description>
    </property>
    <property>
        <name>query.remote-task.max-error-duration</name>
        <value>5m</value>
        <description>无法与协调器通信的远程任务的超时值.如果协调器在达到此值之前无法从远程任务接收更新,则协调器将该任务视为失败.
            配置案例:1d(1天)/1h(1小时)/30m(30分钟)
        </description>
    </property>
    <property>
        <name>spill-enabled</name>
        <value>true</value>
        <description>尝试将内存溢出到磁盘,以避免超出查询的内存限制.
            溢出通过将内存卸载到磁盘来工作.此过程允许通过内存占用较大的查询,但代价是执行时间较慢.聚合、连接(内部和外部)、排序和窗口函数都支持溢出.此属性不会减少其他连接类型所需的内存使用.
        </description>
    </property>
    <property>
        <name>spiller-spill-path</name>
        <value>/data/trino/spill</value>
        <description>写入溢出内容的目录.它可以是一个逗号分隔的列表,可以同时泄漏到多个目录,这有助于利用系统中安装的多个驱动器.
            不建议溢出到系统驱动器.最重要的是,不要溢出到写入JVM日志的驱动器上,因为磁盘过度使用可能会导致JVM长时间暂停,从而导致查询失败.
        </description>
    </property>
    <property>
        <name>spiller-max-used-space-threshold</name>
        <value>0.8</value>
        <description>如果给定溢出路径的磁盘空间使用率高于此阈值,则该溢出路径不符合溢出条件.
        </description>
    </property>
    <property>
        <name>spiller-threads</name>
        <value>4</value>
        <description>溢出线程数.如果默认值不能使底层溢出设备饱和(例如,在使用RAID时),请增加此值.
        </description>
    </property>
    <property>
        <name>max-spill-per-node</name>
        <value>200GB</value>
        <description>单个节点上所有查询使用的最大溢出空间.
        </description>
    </property>
    <property>
        <name>query-max-spill-per-node</name>
        <value>100GB</value>
        <description>单个节点上单个查询使用的最大溢出空间.
        </description>
    </property>
    <property>
        <name>aggregation-operator-unspill-memory-limit</name>
        <value>4MB</value>
        <description>用于展开单个聚合操作符实例的内存限制.
        </description>
    </property>
    <property>
        <name>spill-encryption-enabled</name>
        <value>false</value>
        <description>启用使用随机生成的密钥(每个溢出文件)加密和解密溢出到磁盘的数据.
        </description>
    </property>
    <property>
        <name>exchange.client-threads</name>
        <value>25</value>
        <description>交换客户端用于从其他Trino节点获取数据的线程数.
            较高的值可以提高大型集群或具有非常高并发性的集群的性能,但是过高的值可能会由于上下文切换和额外的内存使用而导致性能下降.
        </description>
        <value-attributes>
            <type>int</type>
            <minimum>1</minimum>
            <increment-step>1</increment-step>
        </value-attributes>
    </property>
    <property>
        <name>exchange.concurrent-request-multiplier</name>
        <value>3</value>
        <description>确定相对于可用缓冲区内存的并发请求数的乘数.
            最大请求数是根据每个请求的平均缓冲区使用量乘以这个乘数,使用可容纳到可用缓冲区空间的客户机数量的启发式方法确定的.
            例如,exchange.max-buffer-size为32MB,并且已经使用了20MB,并且每个请求的平均大小为2MB,则最大客户端数量为multiplier
            * ((32MB - 20MB) / 2MB) = multiplier * 6.
            调整此值可以调整启发式,这可能会增加并发性并提高网络利用率.
        </description>
        <value-attributes>
            <type>int</type>
            <minimum>1</minimum>
            <increment-step>1</increment-step>
        </value-attributes>
    </property>
    <property>
        <name>exchange.data-integrity-verification</name>
        <value>ABORT</value>
        <description>配置数据完整性问题的结果行为.
            默认情况下,当作为内置验证的一部分检测到数据完整性问题时,ABORT将导致查询中止.
            将该属性设置为NONE将禁用验证.当检测到完整性问题时,RETRY会导致重复数据交换.
        </description>
    </property>
    <property>
        <name>exchange.max-buffer-size</name>
        <value>32MB</value>
        <description>交换客户端中保存从其他节点获取的数据的缓冲区大小.
            更大的缓冲区可以为更大的集群增加网络吞吐量,从而减少查询处理时间,但会减少用于其他用途的可用内存量.
        </description>
    </property>
    <property>
        <name>exchange.max-response-size</name>
        <value>16MB</value>
        <description>从交换请求返回的响应的最大大小.
            响应被放置在交换客户端缓冲区中,该缓冲区在交换的所有并发请求之间共享.
            如果存在高延迟,增加该值可能会提高网络吞吐量.
            降低该值可以提高大型集群的查询性能,因为它减少了倾斜,因为交换客户端缓冲区保存更多任务的响应,而不是保存来自更少任务的更多数据.
            最小值为1MB.
        </description>
    </property>
    <property>
        <name>sink.max-buffer-size</name>
        <value>32MB</value>
        <description>等待上游任务提取的任务数据的输出缓冲区大小.
            如果任务输出是散列分区的,那么缓冲区将在所有分区的使用者之间共享.
            如果网络有高延迟,或者集群中有很多节点,增加这个值可以提高在阶段之间传输数据的网络吞吐量.
        </description>
    </property>
    <property>
        <name>sink.max-broadcast-buffer-size</name>
        <value>200MB</value>
        <description>等待上游任务提取的任务数据的广播输出缓冲区大小.
            广播缓冲区用于存储和传输复制连接的构建端数据.
            如果缓冲区太小,则在向集群添加新节点时,它会阻止扩展连接探测端任务.
        </description>
    </property>
    <property>
        <name>task.http-response-threads</name>
        <value>100</value>
        <description>为处理HTTP响应而创建的最大线程数.
            线程是按需创建的,并在空闲时清理,因此,如果要处理的请求数量很少,则不会有很大的开销.
            对于具有大量并发查询的集群,或者具有数百或数千个工作线程的集群,更多的线程可能会有所帮助.
        </description>
        <value-attributes>
            <type>int</type>
            <minimum>1</minimum>
            <increment-step>1</increment-step>
        </value-attributes>
    </property>
    <property>
        <name>task.http-timeout-threads</name>
        <value>3</value>
        <description>生成HTTP响应时用于处理超时的线程数.
            如果经常使用所有线程,则应该增加该值.这可以通过trino进行监控.
            server:name=AsyncHttpExecutionMBean:TimeoutExecutor JMX对象.如果ActiveCount总是与PoolSize相同,则增加线程数.
        </description>
        <value-attributes>
            <type>int</type>
            <minimum>1</minimum>
            <increment-step>1</increment-step>
        </value-attributes>
    </property>
    <property>
        <name>task.info-update-interval</name>
        <value>3s</value>
        <description>控制在调度中使用的任务信息的过时性.较大的值可以减少协调器CPU负载,但可能导致次优的分割调度.
            该配置项设置的范围:[1ms~10s]
        </description>
    </property>
    <property>
        <name>task.max-drivers-per-task</name>
        <value>2147483647</value>
        <description>控制一个任务并发运行的驱动程序的最大数目.
            设置此值可以减少任务使用太多驱动程序的可能性,并可以提高并发查询性能.
            如果运行的并发查询太少,可能会导致资源浪费.
        </description>
        <value-attributes>
            <type>int</type>
            <minimum>1</minimum>
            <increment-step>1</increment-step>
        </value-attributes>
    </property>
    <property>
        <name>task.max-partial-aggregation-memory</name>
        <value>16MB</value>
        <description>对于分布式聚合,部分聚合结果的最大大小.
            增加这个值可以减少网络传输和降低CPU利用率,因为允许在刷新之前将更多的组保存在本地,但代价是额外的内存使用.
        </description>
    </property>
    <property>
        <name>task.min-drivers-per-task</name>
        <value>3</value>
        <description>给定任务还有剩余的分割要处理,保证单个任务并发运行的驱动程序的最小数量.
        </description>
        <value-attributes>
            <type>int</type>
            <minimum>1</minimum>
            <increment-step>1</increment-step>
        </value-attributes>
    </property>
    <property>
        <name>optimizer.optimize-metadata-queries</name>
        <value>false</value>
        <description>通过使用存储为元数据的值来启用某些聚合的优化.
            这允许Trino在常量时间内执行一些简单的查询.
            目前,这种优化适用于分区键的max、min和approx_distinct,以及其他对输入基数不敏感的聚合,包括DISTINCT聚合.使用它可能会显著提高某些查询的速度.
            其主要缺点是,如果连接器为没有行的分区返回分区键,则可能产生不正确的结果.特别是,Hive连接器可以返回空分区,如果它们是由其他系统创建的.Trino不能创造它们.
        </description>
    </property>
    <property>
        <name>optimizer.max-reordered-joins</name>
        <value>9</value>
        <description>当优化器.连接-重新排序策略设置为基于成本的,此属性确定一次可以重新排序的连接的最大数量.
            可能的连接顺序数量随关系数量成阶乘缩放,因此增加此值可能会导致严重的性能问题.
        </description>
    </property>
    <property>
        <name>optimizer.optimize-duplicate-insensitive-joins</name>
        <value>true</value>
        <description>当优化器检测到可以跳过重复的连接输出行时,减少连接产生的行数.
        </description>
    </property>
    <property>
        <name>optimizer.use-exact-partitioning</name>
        <value>false</value>
        <description>除非上游阶段的分区与下游阶段的期望完全匹配,否则重新分区数据.这也可以使用use_exact_partitioning会话属性来指定.
        </description>
    </property>
    <property>
        <name>optimizer.use-table-scan-node-partitioning</name>
        <value>true</value>
        <description>在读取表时使用连接器提供的表节点分区.例如,表节点分区对应Hive表桶.当设置为true并且匹配或超过最小分区与任务比率时,每个表分区由单独的工作程序读取.最小比率在optimizer.table-scan-node-partitioning-min-bucket-to-task-ratio中定义.
            为了并行处理,分区读取器分配分布在各个worker之间.使用表扫描节点分区可以通过降低查询复杂性来提高查询性能.例如,在处理聚合查询时,可能不需要集群范围的数据重组.但是,当分区计数低于工作线程数时,查询并行性可能会降低.
        </description>
    </property>
    <property>
        <name>optimizer.table-scan-node-partitioning-min-bucket-to-task-ratio</name>
        <value>0.5</value>
        <description>指定为了使用表扫描节点分区必须匹配或超过的最小桶与任务比率.当表桶数与工作线程数相比较小时,表扫描将分布在所有工作线程上,以提高并行性.
        </description>
    </property>
    <property>
        <name>optimizer.filter-conjunction-independence-factor</name>
        <value>0.75</value>
        <description>衡量独立假设的强度,以估计多个谓词连接的选择性.该属性的较低值将产生更保守的估计,因为它假设连接中的谓词列之间的相关性更大.如果值为0,则优化器会假设谓词的列是完全相关的,并且只有最具选择性的谓词驱动谓词组合的选择性.
            配置值范围:[0~1],浮点类型
        </description>
        <value-attributes>
            <type>float</type>
            <minimum>0</minimum>
            <maximum>1</maximum>
            <increment-step>0.01</increment-step>
        </value-attributes>
    </property>
    <property>
        <name>optimizer.join-multi-clause-independence-factor</name>
        <value>0.25</value>
        <description>衡量用于估计多子句连接输出的独立性假设的强度.该属性的较低值将产生更保守的估计,因为它假设连接中子句列之间的相关性更大.如果值为0,则优化器会假设连接子句的列是完全相关的,并且只有最具选择性的子句驱动连接的选择性.
            配置值范围:[0~1],浮点类型
        </description>
        <value-attributes>
            <type>float</type>
            <minimum>0</minimum>
            <maximum>1</maximum>
            <increment-step>0.01</increment-step>
        </value-attributes>
    </property>
    <property>
        <name>optimizer.non-estimatable-predicate-approximation.enabled</name>
        <value>true</value>
        <description>启用过滤器的输出行数的近似值,即使使用完整的统计信息也无法准确估计其成本.这允许优化器在存在先前未估计的过滤器的情况下生成更有效的计划.
        </description>
    </property>
    <property>
        <name>optimizer.join-partitioned-build-min-row-count</name>
        <value>1000000</value>
        <description>使用分区连接查找所需的最小连接构建侧行数.如果估计连接的构建端小于配置的阈值,则使用单线程连接查找来提高连接性能.值为0禁用此优化.
        </description>
        <value-attributes>
            <type>int</type>
            <minimum>0</minimum>
            <increment-step>1</increment-step>
        </value-attributes>
    </property>
</configuration>